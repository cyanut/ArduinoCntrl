####################
#TIME OUT DECORATORS
def cdquit(fn_name):
	sys.stderr.flush()
	thread.interrupt_main()
def exit_after(s):
	def outer(fn):
		def inner(*args,**kwargs):
			timer = threading.Timer(s, cdquit, args=[fn.__name__])
			timer.start()
			try:
				result = fn(*args,**kwargs)
			finally:
				timer.cancel()
			return result
		return inner
	return outer
####################

####################
#ARDUINO COMMUNICATIONS
def sendToArduino(sendStr):
	ser.write(sendStr)
def recvFromArduino():
	global startMarker, endMarker
	ck = ""
	x = "z"
	byteCount = -1
	while ord(x) != startMarker:
		x = ser.read()
	while ord(x) != endMarker:
		if ord(x) != startMarker:
			ck = ck + x
			byteCount += 1
		x = ser.read()
	return(ck)
@exit_after(10)
def waitForArduino():
	global startMarker, endMarker
	msg = ""
	print "Attempting to communicate with Arduino..."
	i = 0
	while msg.find("Arduino is ready") == -1:
		while ser.inWaiting() == 0:
			time.sleep(0.1)
			if (i+1)%10==0 and ((i+1)<30 or (i+1)>30):
				sys.stdout.write("\rWaiting.."+"."*(i/10))
			if i+1 == 30:
				sys.stdout.write("\rArduino is taking longer than usual to connect...\nWaiting.....")
			sys.stdout.flush()
			i += 1
		msg = recvFromArduino()
	print "\n\nArduino connection Established! Sending data packets..."
def sendPackets(*args):
	for each in args:
		for i in range(len(each)):
			if len(each)>0:
				retStr = recvFromArduino()
				if retStr == "M":
					sendToArduino(pack(*each[i]))
def startSerial():
	global ser, serPort, baudRate, mainLoopbrk, num_loops, reset
	serialbrkMain = 0
	while serialbrkMain == 0:
		try:
			if num_loops == 0 or reset != 0:
				ser = serial.Serial(serPort,baudRate)
			elif num_loops > 0:
				ser.setDTR(False)
				time.sleep(0.022)
				ser.setDTR(True)
			print gfxBar(40)
			print "OPENED: Port [" + serPort + "] @ Baudrate [" + str(baudRate) + "]"
			try:
				waitForArduino()
				reset = 0
				break
			except IOError:
				print "\n"*4+"Serial Port [%s] is either occupied or cannot be opened." %serPort
				reset = 1
			except KeyboardInterrupt:
				print "\n\n\n\nArduino is taking too long to respond."
				print "Serial Port has been [RESET]. Please select a new one."
				raw_input("Press [enter] to continue: ")
				print "\n"*2
				serPort, reset = "[resetPortReset]", 1
		except (serial.SerialException, IOError):
			print "\n"*4+"Serial Port [%s] is either occupied or cannot be opened." %serPort
			reset = 1
		serialPorts = list_serial_ports()
		serialPortsMsg = "\n".join(str(i)+" - ["+serialPorts[i]+"]" for i in range(len(serialPorts)))
		print gfxBar(0,1,"LIST OF AVAILABLE SERIAL PORTS:\n\n"+serialPortsMsg)
		serialbrkOptions = 0
		while serialbrkOptions == 0:
			if serPort != "[resetPortReset]":
				print "[Y] - Try Port [%s] Again" % serPort
			print "[N] - Exit This Program Session"
			print str([i for i in range(len(serialPorts))]) + " - Select a different Serial Port."
			ask_exit = raw_input("Select an option from above: ").lower()
			ask_exitErrorMsg = "\nType [Y/N] or "+str([i for i in range(len(serialPorts))])+" to Continue"
			try:
				ask_exit = int(ask_exit)
				if ask_exit in range(len(serialPorts)):
					serPort = serialPorts[ask_exit]
					f = open(prgmDir+"settings.txt","r")
					temp = []
					for i in range(5):
						temp.append(f.readline())
					f.close()
					f = open(prgmDir+"settings.txt","w")
					f.write(serialPorts[ask_exit]+"\n")
					for i in range(4):
						f.write(temp[i+1])
					f.close()
					print "\n\nTrying New Serial Port [%s]" % serPort
					break
				else:
					if serPort == "[resetPortReset]":
						print ask_exitErrorMsg[:7]+ask_exitErrorMsg[9:]
					else:
						print ask_exitErrorMsg
			except ValueError:
				if ask_exit == "y" and serPort != "[resetPortReset]":
					print "\n\nTrying Serial Port[%s] Again..." % serPort
					break
				elif ask_exit == "n":
					print "\n"*40+"Exiting Program...\nFinished."
					mainLoopbrk = 1
					serialbrkMain = 1
					break
				else:
					if serPort == "[resetPortReset]":
						print ask_exitErrorMsg[:7]+ask_exitErrorMsg[9:]
					else:
						print ask_exitErrorMsg
####################

####################
#MISC FUNCTIONS
def posToInt(a):
	if a < 8:
		return (int("1"+"0"*int(a),2))
	if a >= 8 and a <= 13:
		return (int("1"+"0"*(int(a)-8),2))


def consoleResize(x,y):
	if sys.platform.startswith('win'):
		os.system("mode con: cols=%s lines=%s"%(x, y))
	elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'):
		sys.stdout.write("\x1b[8;{rows};{cols}t".format(rows=y, cols=x))
		sys.stdout.flush()
	elif sys.platform.startswith('darwin'):
		sys.stdout.write("\x1b[8;{rows};{cols}t".format(rows=y, cols=x))
		sys.stdout.flush()
	else:
		raise EnvironmentError('Unsupported platform')
def dictFlatten(*args):
	hold = []
	for a in args:
		hold.append([i for s in a.values() for i in s])
	return hold

def fileMultiWrite(file_name,*args):
	global presetDir
	f = open(presetDir+file_name+".txt","w")
	for i in args:
		f.write(str(i)+"\n")
	f.close()

####################

####################
#IMAGE ELEMENTS
def gfxBar(upperClearance=0,lowerClearance=0,msg=0):
	if msg == 0:
		return "\n"*upperClearance+"#"*65+"\n"*lowerClearance
	else:
		return "\n"*upperClearance+"#"*65+"\n"+msg+"\n"+"#"*65+"\n"*lowerClearance
def gfxWord(types):
	if types == "tone":
		print "_________ _______  _        _______  _______ "
		print "\__   __/(  ___  )( (    /|(  ____ \(  ____ \\"
		print "   ) (   | (   ) ||  \  ( || (    \/| (    \/"
		print "   | |   | |   | ||   \ | || (__    | (_____ "
		print "   | |   | |   | || (\ \) ||  __)   (_____  )"
		print "   | |   | |   | || | \   || (            ) |"
		print "   | |   | (___) || )  \  || (____/\/\____) |"
		print "   )_(   (_______)|/    )_)(_______/\_______)"
	elif types == "output":
		print " _______          _________ _______          _________"
		print "(  ___  )|\     /|\__   __/(  ____ )|\     /|\__   __/"
		print "| (   ) || )   ( |   ) (   | (    )|| )   ( |   ) (   "
		print "| |   | || |   | |   | |   | (____)|| |   | |   | |   "
		print "| |   | || |   | |   | |   |  _____)| |   | |   | |   "
		print "| |   | || |   | |   | |   | (      | |   | |   | |   "
		print "| (___) || (___) |   | |   | )      | (___) |   | |   "
		print "(_______)(_______)   )_(   |/       (_______)   )_(   "
	elif types == "pwm":
		print " _______           _______ "
		print "(  ____ )|\     /|(       )"
		print "| (    )|| )   ( || () () |"
		print "| (____)|| | _ | || || || |"
		print "|  _____)| |( )| || |(_)| |"
		print "| (      | || || || |   | |"
		print "| )      | () () || )   ( |"
		print "|/       (_______)|/     \|"
def gfxFormat(types,sep):
	on, off, pin, freq, duty, phase = "SECONDS_UNTIL_ON","SECONDS_ON_FOR","PIN_USED","FREQUENCY_HZ","DUTY_CYCLE(%)", "PHASE_SHIFT"
	msg = on+sep+off+sep
	if types == "tone":
		msg = msg+freq
	elif types == "output":
		msg = msg+pin
	elif types == "pwm":
		msg = msg+freq+sep+pin+sep+duty+sep+phase
	if sep == " | ":
		msg = sep+msg+sep
	return msg
def gfxSetup(types):
	print gfxBar(40)
	gfxWord(types)
	print gfxBar(0,0,"[INPUT FORMAT]: "+gfxFormat(types,", "))
	if types == "tone":
		print ">>>USE FOR FREQUENCIES [>50HZ].\n"
	if types == "output":
		print ">>>USE PINS 2-7 (INCLUSIVE).\n"
	if types == "pwm":
		print ">>>USE PINS 8-13 (INCLUSIVE, EXCEPT 10)."
		print ">>>USE FOR FREQUENCIES [<100HZ].\n"

####################

####################
#GET USER INPUTS

####################

####################
#TURN USER INPUTS INTO DATA PACKETS

def runExperiment():
	global packet, tone_pack, out_pack, pwm_pack, num_loops, mainLoopbrk, reset, resultsDir, ljSaveName, cameraSaveName, runDone
	stopLoop = 0
	sendToArduino(pack("<B",1))
	while True:
		print "\n"*40+"#"*10
		print "The experiment has started."
		print "Arduino millisecond counter has been reset to [0ms]."
		print gfxBar()
		###
		#RUNNING TIMER
		timeSegment = float(float(packet[3])/float(100))
		print "-"*100+" [TOTAL TIME]: [" +str(packet[3]/1000) +"s]"
		print " "*101+"|  ON -  OFF|PIN|Freq-DtyCycl-PhsShft|"
		gfxTimeDisplay("tones",tone_pack,timeSegment)
		gfxTimeDisplay("simple outputs",out_pack,timeSegment)
		gfxTimeDisplay("frequency modulated outputs",pwm_pack,timeSegment)
		###
		#PROGRESS BAR HERE
		startProg = datetime.now()
		barCounter, timeCounter = 0, 0.0
		segmentSize = (float(packet[3])/1000)/100
		timeSize = 0.1
		numTime, numProg = 1, 1
		while True:
			now = datetime.now()
			timeDiff = (now-startProg).seconds+float((now-startProg).microseconds)/1000000
			if timeDiff/numTime >= timeSize:
				numTime += 1
				timeCounter += timeSize
			if timeDiff/numProg >= segmentSize:
				numProg += 1
				barCounter += 1
			if barCounter == 0:
				barCounter, timeCounter = min(barCounter,99), min(timeCounter,float(packet[3]/1000)-0.1)
				sys.stdout.write("\r"+"*"+"-"*(99-barCounter)+" ["+str(timeCounter)+"s]")
				sys.stdout.flush()
			elif barCounter in range(1,100):
				barCounter, timeCounter = min(barCounter,99), min(timeCounter,float(packet[3]/1000)-0.1)
				sys.stdout.write("\r"+"-"*(barCounter-1)+"|"+"-"*(100-barCounter)+" ["+str(timeCounter)+"s]")
				sys.stdout.flush()
			elif barCounter >= 100 and timeCounter >= float(packet[3]/1000)-timeSize:
				barCounter, timeCounter = 100, float(packet[3]/1000)
				sys.stdout.write("\r"+"-"*(barCounter-1)+"*"+" [Finished: "+str(timeCounter)+"s]")
				sys.stdout.flush()
				break
		###
		try:
			ardMsg2 = recvFromArduino()
			endMillis = ardMsg2.split(",")[0]
			startRTC = ardMsg2.split(",")[1]
			endRTC = ardMsg2.split(",")[2]
		except serial.serialutil.SerialException:
			print gfxBar(2)
			print "[ATTN]: The Arduino was disconnected during the experiment."
			raw_input("Reconnect the hardware and press [enter] to try again: ")
			stopLoop, reset = 1, 1
			num_loops += 1
			break
		print gfxBar(1)
		print "The experiment has ended."
		print "Arduino reports exactly [%s ms], from [%s] to [%s]." % (endMillis, startRTC, endRTC)
		print "#"*10
		runDone = 1
		break
	while True:
		if runDone == 2:
			break
		time.sleep(0.001)
	print "\n"*2+"[SAVE DIRECTORY]: '"+resultsDir+"'"
	print "[LABJACK DATA  ]: '"+ljSaveName+".csv'"
	print "[VIDEO OUTPUT  ]: '"+cameraSaveName+".mp4'"
	raw_input("Press [enter] to Continue")
	while True:
		userPlot = raw_input("\nGraph your Data? (Y/N): ").lower()
		if userPlot == "y":
			print "Your plot will appear in your system's default browser.\nThis may take a moment for long procedures..."
			plotData()
			break
		elif userPlot == "n":
			break
		else:
			print "Type (Y/N) to Continue"
	while stopLoop == 0:
		user_stop = raw_input("\nRerun experiment? (Y/N): ").lower()
		if user_stop == "y":
			num_loops += 1
			break
		elif user_stop == "n":
			mainLoopbrk = 1
			cameraClose(cameraCtx)
			print "\n"*40+"Finished."
			break
		else:
			print "Type (Y/N) to Continue"
####################

####################
#LABJACK CONFIGURATION


def startLJ(lj):
	global nCh, chNum, chOpt, stlFctr, ResIndx, scanFreq
	lj.getCalibrationData()
	lj.streamConfig(nCh,ResIndx,25,stlFctr,0,False,1,chNum,chOpt,scanFreq,None)
	return lj
class StreamDataReader(object):
    def __init__(self, device):
        self.device = device
        self.data = Queue.Queue()
        self.dataCountMain = 0
        self.dataCountAux1 = 0
        self.dataCountAux2 = 0
        self.running = False
    def readStreamData(self):
        global timeStart, packet, nCh, runDone, timeStartRead, sdrMissedList
        global sdrMissed, beforeStart, runTime, afterStop, ttlRunTime
        global sdrTotalAux1, sdrTotalAux2, sdrTotalMain, sdrTotal
        global finalSmplFreq, finalScanFreq, finalSmplFreqExp, finalScanFreqExp
        global missedBefore, missedDuring, missedAfter
        self.running = True
        self.device.streamStart()
        timeStartRead = datetime.now()
        while True:
            returnDict = self.device.streamData(convert = False).next()
            self.data.put_nowait(copy.deepcopy(returnDict))
            self.dataCountAux1 += 1
            if self.dataCountAux1 >= SMALL_REQUEST:
                break
        timeStart = datetime.now()
        while True:
            returnDict = self.device.streamData(convert = False).next()
            self.data.put_nowait(copy.deepcopy(returnDict))
            self.dataCountMain += 1
            if self.dataCountMain >= MAX_REQUESTS:
                break
        stop = datetime.now()
        while self.running:
            returnDict = self.device.streamData(convert = False).next()
            self.data.put_nowait(copy.deepcopy(returnDict))
            self.dataCountAux2 += 1
            if self.dataCountAux2 >= SMALL_REQUEST:
                self.running = False
        stopRead = datetime.now()
        self.device.streamStop()
        self.device.close()
        #Total Samples Taken for each interval
        multiplier =  self.device.packetsPerRequest * self.device.streamSamplesPerPacket
        sdrTotalAux1 = (self.dataCountAux1)*multiplier
        sdrTotalMain = (self.dataCountMain)*multiplier
        sdrTotalAux2 = (self.dataCountAux2)*multiplier
        sdrTotal = sdrTotalAux1+sdrTotalMain+sdrTotalAux2
        #Total run times for each interval
        runTime = float((stop-timeStart).seconds*1000) + float((stop-timeStart).microseconds)/1000
        beforeStart = float((timeStart-timeStartRead).seconds*1000) + float((timeStart-timeStartRead).microseconds)/1000
        afterStop = float((stopRead-stop).seconds*1000) + float((stopRead-stop).microseconds)/1000
        ttlRunTime = float((stopRead-timeStartRead).seconds*1000) + float((stopRead-timeStartRead).microseconds)/1000
        #Real sampling frequency for experiment and for entire duration
        finalSmplFreq = int(round(float(sdrTotal)*1000/(ttlRunTime)))
        finalScanFreq = int(round(float(sdrTotal)*1000/(nCh*ttlRunTime)))
        finalSmplFreqExp = int(round(float(sdrTotalMain)*1000/(runTime)))
        finalScanFreqExp = int(round(float(sdrTotalMain)*1000/(nCh*runTime)))
        #Reconstructing when and where missed values occured
        missedBefore, missedDuring, missedAfter = 0, 0, 0
        if len(sdrMissedList) != 0:
	        for i in sdrMissedList:
	        	if i[1] <= float(int(beforeStart))/1000:
	        		missedBefore += i[0]
	        	elif i[1] > float(int(beforeStart))/1000 and i[1] <= float(int(beforeStart))/1000+float(int(runTime))/1000:
	        		missedDuring += i[0]
	        	elif i[1] > float(int(beforeStart))/1000+float(int(runTime))/1000 and i[1] <= float(int(beforeStart))/1000+float(int(runTime))/1000+float(int(afterStop))/1000:
	        		missedAfter += i[0]
        while True:
        	warning = False
        	if sdrMissed != 0:
        		warning = True
	        if runDone == 1:
	        	#Uncomment the following to see LJ Diagnostics, if needed.
	        	print "\n"+"#"*10+"\n[LABJACK REPORT]\n(this information is also saved in your data file)"
	        	print "__________________________________________________________________"
	        	print "                  | BEFORE | DURING EXPERIMENT | AFTER  |  TOTAL |"
	        	print "          TIME (s)|%s|     %s     |%s|%s|" % (printDigits(float(int(beforeStart))/1000,8),printDigits(float(int(runTime))/1000,9),
	        		printDigits(float(int(afterStop))/1000,8),printDigits(float(int(ttlRunTime))/1000,8))
	        	print "     SAMPLES TAKEN|%s|     %s     |%s|%s|" % (printDigits(sdrTotalAux1,8),printDigits(sdrTotalMain,9),printDigits(sdrTotalAux2,8),printDigits(sdrTotal,8))
	        	print "    SAMPLES MISSED|%s|     %s     |%s|%s|" % (printDigits(missedBefore,8),printDigits(missedDuring,9),printDigits(missedAfter,8),printDigits(sdrMissed,8))
	        	print "SAMPLING FREQ (Hz)|        |     %s     |        |%s|" % (printDigits(finalSmplFreqExp,9),printDigits(finalSmplFreq,8))
	        	print "    SCAN FREQ (Hz)|        |     %s     |        |%s|" % (printDigits(finalScanFreqExp,9),printDigits(finalScanFreq,8))
		        print "------------------------------------------------------------------"
		        print "*(Camera and Arduino are turned on only DURING_EXPERIMENT)"
		        print "#"*10
		        if warning:
		        	print
		        	print "#"*30
		        	print "!![ATTN]!! ---> The Labjack missed [%s] values! Please take a look at the labjack report." % sdrMissed
		        	print "           ---> You may wish to repeat this trial if many values were lost"
		        	print "           ---> You may also wish to reduce the labjack's SCAN_FREQUENCY after restarting the script."
		        	print "#"*30
		        	raw_input("Press [enter] to continue: ")
		        runDone = 2
		        break
			time.sleep(0.00001)
class readThread(threading.Thread):
	def __init__(self,sdr):
		threading.Thread.__init__(self)
		self.sdr = sdr
	def run(self):
		global chNum, nCh, ljSaveName, runDone, expName, sdrMissedList
		global sdrMissed, beforeStart, runTime, afterStop, ttlRunTime
		global sdrTotalAux1, sdrTotalAux2, sdrTotalMain, sdrTotal
		global finalSmplFreq, finalScanFreq, finalSmplFreqExp, finalScanFreqExp
		global missedBefore, missedDuring, missedAfter, hiddenOption
		sdrMissed, sdrMissedList = 0, []
		ljSaveName = "["+expName+"]-"+getDay(3)
		f = open(resultsDir+ljSaveName+".csv","w")
		for i in range(nCh):
			f.write("AIN"+str(chNum[i])+",")
		f.write("\n")
		while True:
			try:
				if not self.sdr.running:
					break
				result = self.sdr.data.get(True, 1)
				if result['errors'] != 0:
					sdrMissed += result['missed']
					missedTime = datetime.now()
					timeDiff = str((missedTime - timeStartRead).seconds*1000+(missedTime - timeStartRead).microseconds/1000)
					sdrMissedList.append([copy.deepcopy(result['missed']),copy.deepcopy(float(timeDiff)/1000)])
					print "\n>>>LabJack reported [%s] Errors: " % result['errors']
					print ">>>We lost [%s] values at [%sms] since Start." % (result['missed'], timeDiff)
					print ">>>If this continues, you may wish to reduce your LabJack SCAN_FREQUENCY after restarting the script."
				r = ljDAQ.processStreamData(result['result'])
				for each in range(len(r["AIN"+str(chNum[0])])):
					for i in range(nCh):
						f.write(str(r["AIN"+str(chNum[i])][each])+",")
					f.write("\n")
			except Queue.Empty:
				print "Queue is empty. Stopping..."
				self.sdr.running = False
				break
			except KeyboardInterrupt:
				self.sdr.running = False
			except Exception:
				e = sys.exc_info()[1]
				print type(e), e
				self.sdr.running = False
				break
		f.close()
		while True:
			if runDone == 2:
				if hiddenOption == "p":
					topLine = " , BEFORE EXP, DURING EXP, AFTER EXP, TOTAL, TRUE DATA CH,TRUE REF CH, ISOS DATA CH, ISOS REF CH, TRUE REF FREQ, ISOS REF FREQ\n"
					timeLine = "TIME (s),%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,\n" % (printDigits(float(int(beforeStart))/1000,8),
						printDigits(float(int(runTime))/1000,9), printDigits(float(int(afterStop))/1000,8),
						printDigits(float(int(ttlRunTime))/1000,8),photometryConfig1[0],photometryConfig1[1],
						photometryConfig1[2],photometryConfig1[3],photometryConfig2[0],photometryConfig2[1])
				else:
					topLine = " , BEFORE EXP, DURING EXP, AFTER EXP, TOTAL,\n"
					timeLine = "TIME (s),%s,%s,%s,%s,\n" % (printDigits(float(int(beforeStart))/1000,8),
						printDigits(float(int(runTime))/1000,9), printDigits(float(int(afterStop))/1000,8),
						printDigits(float(int(ttlRunTime))/1000,8))
				samplesLine = "SAMPLES TAKEN,%s,%s,%s,%s,\n" % (printDigits(sdrTotalAux1,8),printDigits(sdrTotalMain,9),
					printDigits(sdrTotalAux2,8),printDigits(sdrTotal,8))
				smplsMissedLine = "SAMPLES MISSED,%s,%s,%s,%s,\n" % (missedBefore, missedDuring, missedAfter, sdrMissed)
				smplFreqLine = "SAMPLING FREQ (HZ), ,%s, ,%s,\n" % (printDigits(finalSmplFreqExp,9),printDigits(finalSmplFreq,8))
				scanFreqLine = "SCAN FREQ (HZ), ,%s, ,%s,\n" % (printDigits(finalScanFreqExp,9),printDigits(finalScanFreq,8))
				stats = topLine+timeLine+samplesLine+smplsMissedLine+smplFreqLine+scanFreqLine
				with file(resultsDir+ljSaveName+".csv", "r") as original: data = original.read()
				with file(resultsDir+ljSaveName+".csv", "w") as modified: modified.write(stats + data)
				break
			time.sleep(0.00001)
####################
#GRAPHING RESULT DATA
def plotData():
	import plotly
	from plotly.graph_objs import Scatter, Layout, Figure
	import plotly.plotly as py
	import plotly.graph_objs as go
	global ttlRunTime
	linesTop = 6
	totalScans = -(1+linesTop)
	with open(resultsDir+ljSaveName+".csv") as fil:
		for line in fil:
			if line.strip():
				totalScans += 1
	axisTime, name, axisSignal, traces = [], [], {}, {}
	f = open(resultsDir+ljSaveName+".csv","r")
	for i in range(linesTop):
		f.readline()
	name = f.readline()[:-1].split(",")
	for i in range(nCh):
		axisSignal[i] = []
	timeSeg = float(float(ttlRunTime)/1000)/totalScans
	for i in range(totalScans):
		axisTime.append(i*timeSeg)
		hold = f.readline()[:-1].split(",")
		for i in range(nCh):
			axisSignal[i].append(hold[i])
	f.close()
	for i in range(nCh):
		traces[i] = go.Scatter(
			x = axisTime,
			y = axisSignal[i],
			name = "Channel "+name[i])
	data = []
	for i in range(nCh):
		data.append(traces[i])
	layout = go.Layout(
		title="\n"+ljSaveName,
		xaxis=dict(
			title="Time (s)"),
		yaxis=dict(
			title="Signal (V)"))
	plotly.offline.plot(
		{"data": data,
		"layout": layout})
####################
#CAMERA FUNCTION
def cameraSetup():
    c = fc2.Context()
    c.connect(*c.get_camera_from_index(0))
    c.set_video_mode_and_frame_rate(fc2.VIDEOMODE_640x480Y8, fc2.FRAMERATE_30)
    p = c.get_property(fc2.FRAME_RATE)
    c.set_property(**p)
    c.start_capture()
    return c
def cameraRecord(name,c,numFrames):
    c.set_strobe_mode(3, True, 1, 0, 10)
    c.openAVI(name, frate=30, bitrate=1000000)
    for i in range(numFrames):
        c.appendAVI()
    c.set_strobe_mode(3, False, 1, 0, 10)
    while True:
    	time.sleep(0.00001)
    	if runDone == 2:
    		break
    c.closeAVI()
def cameraClose(c):
    c.stop_capture()
    c.disconnect()
class cameraThread(threading.Thread):
	def __init__(self):
		threading.Thread.__init__(self)
	def run(self):
		global cameraSaveName, packet, cameraCtx, expName, resultsDir
		cameraSaveName = "["+expName+"]-"+getDay(3)
		numFrames = (packet[3]/1000)*30
		cameraRecord(resultsDir+cameraSaveName, cameraCtx, numFrames)
##############################################################################################################
#=================================================PROGRAM====================================================#
##############################################################################################################
####################
#ARDUINO CNTRL VARIABLES
serPort, baudRate = "", 115200
userhome = os.path.expanduser('~')
baseDir = userhome+"/desktop/arduinoControl/"
presetDir = baseDir+"UserPresets/"
prgmDir = baseDir+"prgmSettings/"
saveDir = baseDir+"outputSaves/"
settings = "enter_new"
startMarker, endMarker = 60, 62
timeOffset = 3600*4 #EST = -4 hours.
fullscreenMsg = ""
num_loops, reset, mainLoopbrk = 0, 0, 0
prevTimeStart, prevTimeStartRead = datetime.now(), datetime.now()
timeStart, timeStartRead = copy.deepcopy(prevTimeStart), copy.deepcopy(prevTimeStartRead)
runDone = 0
####################

#SETUP LABJACK DAQ and PTGREY CAMERA
cameraCtx = cameraSetup()

####################
#MAIN PROGRAM LOOP

	####################
	#GET INPUTS. START SERIAL
	run_setup(settings)
	startSerial()
	if mainLoopbrk == 1:
		break
	####################
	#SEND DATA
	sysTime = ["<L",calendar.timegm(time.gmtime())-timeOffset]
	pwm_packSend = []
	for i in pwm_pack:
		period = (float(1000000)/float(i[4]))
		cycleTimeOn = long(round(period*(float(i[7])/float(100))))
		cycleTimeOff = long(round(period*(float(1)-((float(i[7])/float(100))))))
		timePhaseShift = long(round(period*(float(i[6])/float(360))))
		pwm_packSend.append(["<LLLLLBL",0,i[2],i[3],cycleTimeOn,cycleTimeOff,i[5],timePhaseShift])
	allowExp = 0
	try:
		sendPackets([sysTime],[packet],tone_pack,out_pack,pwm_packSend)
		ljDAQ = LJU6()
		ljDAQ = startLJ(ljDAQ)
		sdr = StreamDataReader(ljDAQ)
		sdrThread = threading.Thread(target = sdr.readStreamData)
		dataReading = readThread(sdr)
		cameraRun = cameraThread()
		MAX_REQUESTS = int(math.ceil((float(scanFreq*nCh*packet[3]/1000)/float(packsPerReq*smplsPerPack))))
		SMALL_REQUEST = int(round((float(scanFreq*nCh*0.5)/float(packsPerReq*smplsPerPack))))
		#USER TRIGGER
		raw_input("Press 'Enter' To Begin ")
		#RUN
		allowExp = 1
		if allowExp == 1:
			runDone = 0
			sdrThread.start()
			while True:
				if timeStartRead != prevTimeStartRead:
					prevTimeStartRead = timeStartRead
					break
				time.sleep(0.00001)
			dataReading.start()
			while True:
				if timeStart != prevTimeStart:
					prevTimeStart = timeStart
					break
				time.sleep(0.00001)
			cameraRun.start()
			runExperiment()
	#except (LabJackPython.NullHandleException, LabJackPython.LabJackException):
	#	print gfxBar(40)
	#	print "[ATTN]: Please make sure the LabJack is connected."
	#	raw_input("Reconnect the hardware and press [enter] to try again: ")
	#	ser.setDTR(False)
	#	time.sleep(0.022)
	#	reset = 1
	#	num_loops += 1
	#	allowExp = 0
	except serial.serialutil.SerialException:
		print gfxBar(40)
		print "[ATTN]: The Arduino became disconnected before data could be sent."
		raw_input("Reconnect the hardware and press [enter] to try again: ")
		reset = 1
		num_loops += 1
		allowExp = 0
	####################
	#END
####################